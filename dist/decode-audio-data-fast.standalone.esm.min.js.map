{"version":3,"file":"decode-audio-data-fast.standalone.esm.min.js","sources":["../node_modules/mp3-parser/lib/lib.js","../node_modules/mp3-parser/lib/id3v2.js","../node_modules/mp3-parser/lib/xing.js","../node_modules/mp3-parser/main.js","../src/index.js"],"sourcesContent":["//     mp3-parser/lib v0.3.0\n\n//     https://github.com/biril/mp3-parser\n//     Licensed and freely distributed under the MIT License\n//     Copyright (c) 2013-2016 Alex Lambiris\n\n// ----\n\n/* jshint browser:true */\n/* global exports:false, define:false */\n(function (globalObject, createModule) {\n    \"use strict\";\n\n    // Export as a module or global depending on environment:\n\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\n    if (typeof define === \"function\" && define.amd) {\n        return define([\"exports\"], createModule);\n    }\n\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\n    if (typeof exports === \"object\") { return createModule(exports); }\n\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\n    var previousMp3ParserLib = globalObject.mp3ParserLib;\n    createModule(globalObject.mp3ParserLib = {\n        noConflict: function () {\n            var lib = globalObject.mp3ParserLib;\n            globalObject.mp3ParserLib = previousMp3ParserLib;\n            return (this.noConflict = function () { return lib; }).call();\n        }\n    });\n}(this, function (lib) {\n    \"use strict\";\n\n    // Produce octet's binary representation as a string\n    var octetToBinRep = (function () {\n        var b = []; // The binary representation\n        return function (octet) {\n            b[0] = ((octet & 128) === 128 ? \"1\" : \"0\");\n            b[1] = ((octet & 64)  === 64  ? \"1\" : \"0\");\n            b[2] = ((octet & 32)  === 32  ? \"1\" : \"0\");\n            b[3] = ((octet & 16)  === 16  ? \"1\" : \"0\");\n            b[4] = ((octet & 8)   === 8   ? \"1\" : \"0\");\n            b[5] = ((octet & 4)   === 4   ? \"1\" : \"0\");\n            b[6] = ((octet & 2)   === 2   ? \"1\" : \"0\");\n            b[7] = ((octet & 1)   === 1   ? \"1\" : \"0\");\n            return b.join(\"\");\n        };\n    }());\n\n    // Get the number of bytes in a frame given its `bitrate`, `samplingRate` and `padding`.\n    //  Based on [magic formula](http://mpgedit.org/mpgedit/mpeg_format/mpeghdr.htm)\n    lib.getFrameByteLength = function (kbitrate, samplingRate, padding, mpegVersion, layerVersion) {\n        var sampleLength = lib.sampleLengthMap[mpegVersion][layerVersion];\n        var paddingSize = padding ? (layerVersion === \"11\" ? 4 : 1) : 0;\n        var byteRate = kbitrate * 1000 / 8;\n        return Math.floor((sampleLength * byteRate / samplingRate) + paddingSize);\n    };\n\n    lib.getXingOffset = function (mpegVersion, channelMode) {\n        var mono = channelMode === \"11\";\n        if (mpegVersion === \"11\") { // mpeg1\n            return mono ? 21 : 36;\n        } else {\n            return mono ? 13 : 21;\n        }\n    };\n\n    //\n    lib.v1l1Bitrates = {\n        \"0000\": \"free\",\n        \"0001\": 32,\n        \"0010\": 64,\n        \"0011\": 96,\n        \"0100\": 128,\n        \"0101\": 160,\n        \"0110\": 192,\n        \"0111\": 224,\n        \"1000\": 256,\n        \"1001\": 288,\n        \"1010\": 320,\n        \"1011\": 352,\n        \"1100\": 384,\n        \"1101\": 416,\n        \"1110\": 448,\n        \"1111\": \"bad\"\n    };\n\n    //\n    lib.v1l2Bitrates = {\n        \"0000\": \"free\",\n        \"0001\": 32,\n        \"0010\": 48,\n        \"0011\": 56,\n        \"0100\": 64,\n        \"0101\": 80,\n        \"0110\": 96,\n        \"0111\": 112,\n        \"1000\": 128,\n        \"1001\": 160,\n        \"1010\": 192,\n        \"1011\": 224,\n        \"1100\": 256,\n        \"1101\": 320,\n        \"1110\": 384,\n        \"1111\": \"bad\"\n    };\n\n    //\n    lib.v1l3Bitrates = {\n        \"0000\": \"free\",\n        \"0001\": 32,\n        \"0010\": 40,\n        \"0011\": 48,\n        \"0100\": 56,\n        \"0101\": 64,\n        \"0110\": 80,\n        \"0111\": 96,\n        \"1000\": 112,\n        \"1001\": 128,\n        \"1010\": 160,\n        \"1011\": 192,\n        \"1100\": 224,\n        \"1101\": 256,\n        \"1110\": 320,\n        \"1111\": \"bad\"\n    };\n\n    //\n    lib.v2l1Bitrates = {\n        \"0000\": \"free\",\n        \"0001\": 32,\n        \"0010\": 48,\n        \"0011\": 56,\n        \"0100\": 64,\n        \"0101\": 80,\n        \"0110\": 96,\n        \"0111\": 112,\n        \"1000\": 128,\n        \"1001\": 144,\n        \"1010\": 160,\n        \"1011\": 176,\n        \"1100\": 192,\n        \"1101\": 224,\n        \"1110\": 256,\n        \"1111\": \"bad\"\n    };\n\n    //\n    lib.v2l2Bitrates = {\n        \"0000\": \"free\",\n        \"0001\": 8,\n        \"0010\": 16,\n        \"0011\": 24,\n        \"0100\": 32,\n        \"0101\": 40,\n        \"0110\": 48,\n        \"0111\": 56,\n        \"1000\": 64,\n        \"1001\": 80,\n        \"1010\": 96,\n        \"1011\": 112,\n        \"1100\": 128,\n        \"1101\": 144,\n        \"1110\": 160,\n        \"1111\": \"bad\"\n    };\n    lib.v2l3Bitrates = lib.v2l2Bitrates;\n\n    //\n    lib.v1SamplingRates = {\n        \"00\": 44100,\n        \"01\": 48000,\n        \"10\": 32000,\n        \"11\": \"reserved\"\n    };\n\n    //\n    lib.v2SamplingRates = {\n        \"00\": 22050,\n        \"01\": 24000,\n        \"10\": 16000,\n        \"11\": \"reserved\"\n    };\n\n    //\n    lib.v25SamplingRates = {\n        \"00\": 11025,\n        \"01\": 12000,\n        \"10\": 8000,\n        \"11\": \"reserved\"\n    };\n\n    //\n    lib.channelModes = {\n        \"00\": \"Stereo\",\n        \"01\": \"Joint stereo (Stereo)\",\n        \"10\": \"Dual channel (Stereo)\",\n        \"11\": \"Single channel (Mono)\"\n    };\n\n    //\n    lib.mpegVersionDescription = {\n        \"00\": \"MPEG Version 2.5 (unofficial)\",\n        \"01\": \"reserved\",\n        \"10\": \"MPEG Version 2 (ISO/IEC 13818-3)\",\n        \"11\": \"MPEG Version 1 (ISO/IEC 11172-3)\"\n    };\n\n    //\n    lib.layerDescription = {\n        \"00\": \"reserved\",\n        \"01\": \"Layer III\",\n        \"10\": \"Layer II\",\n        \"11\": \"Layer I\"\n    };\n\n    //\n    lib.bitrateMap = {\n        \"11\": {\n            \"01\": lib.v1l3Bitrates,\n            \"10\": lib.v1l2Bitrates,\n            \"11\": lib.v1l1Bitrates\n        },\n        \"10\": {\n            \"01\": lib.v2l3Bitrates,\n            \"10\": lib.v2l2Bitrates,\n            \"11\": lib.v2l1Bitrates\n        }\n    };\n\n    //\n    lib.samplingRateMap = {\n        \"00\": lib.v25SamplingRates,\n        \"10\": lib.v2SamplingRates,\n        \"11\": lib.v1SamplingRates\n    };\n\n    //\n    lib.v1SampleLengths = {\n        \"01\": 1152,\n        \"10\": 1152,\n        \"11\": 384\n    };\n\n    //\n    lib.v2SampleLengths = {\n        \"01\": 576,\n        \"10\": 1152,\n        \"11\": 384\n    };\n\n    //\n    lib.sampleLengthMap = {\n        \"01\": lib.v2SampleLengths,\n        \"10\": lib.v2SampleLengths,\n        \"11\": lib.v1SampleLengths\n    };\n\n    // Convert the given string `str` to an array of words (octet pairs). If all characters in the\n    //  given string are within the ISO/IEC 8859-1 subset then the returned array may safely be\n    //  interpreted as an array of values in the [0, 255] range, where each value requires a single\n    //  octet to be represented. Otherwise it should be interpreted as an array of values in the\n    //  [0, 65.535] range, where each value requires a word (octet pair) to be represented.\n    //\n    // Not meant to be used with UTF-16 strings that contain chars outside the BMP. See\n    //  [charCodeAt on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)\n    lib.wordSeqFromStr = function (str) {\n        for (var i = str.length - 1, seq = []; i >= 0; --i) {\n            seq[i] = str.charCodeAt(i);\n        }\n        return seq;\n    };\n\n    // Common character sequences converted to byte arrays\n    lib.seq = {\n        id3: lib.wordSeqFromStr(\"ID3\"),\n        xing: lib.wordSeqFromStr(\"Xing\"),\n        info: lib.wordSeqFromStr(\"Info\")\n    };\n\n    // A handy no-op to reuse\n    lib.noOp = function () {};\n\n    // Decode a [synchsafe](http://en.wikipedia.org/wiki/Synchsafe) value. Synchsafes are used in\n    //  ID3 tags, instead of regular ints, to avoid the unintended introduction of bogus\n    //  frame-syncs. Note that the spec requires that syncsafe be always stored in big-endian order\n    //  (Implementation shamefully lifted from relevant wikipedia article)\n    lib.unsynchsafe = function (value) {\n        var out = 0;\n        var mask = 0x7F000000;\n\n        while (mask) {\n            out >>= 1;\n            out |= value & mask;\n            mask >>= 8;\n        }\n\n        return out;\n    };\n\n    // Get a value indicating whether given DataView `view` contains the `seq` sequence (array\n    //  of octets) at `offset` index. Note that no check is performed for the adequate length of\n    //  given view as this should be carried out by the caller\n    lib.isSeq = function (seq, view, offset) {\n        for (var i = seq.length - 1; i >= 0; i--) {\n            if (seq[i] !== view.getUint8(offset + i)) { return false; }\n        }\n        return true;\n    };\n\n    // Get a value indicating whether given DataView `view` contains the `str` string\n    //  at `offset` index. The view is parsed as an array of 8bit single-byte coded characters\n    //  (i.e. ISO/IEC 8859-1, _non_ Unicode). Will return the string itself if it does, false\n    //  otherwise. Note that no check is performed for the adequate length of given view as\n    //  this should be carried out be the caller as part of the section-parsing process\n    /*\n    isStr = function (str, view, offset) {\n        return isSeq(lib.wordSeqFromStr(str), view, offset) ? str : false;\n    };\n    */\n\n    // Locate first occurrence of sequence `seq` (an array of octets) in DataView `view`.\n    //  Search starts at given `offset` and ends after `length` octets. Will return the\n    //  absolute offset of sequence if found, -1 otherwise\n    lib.locateSeq = function (seq, view, offset, length) {\n        for (var i = 0, l = length - seq.length + 1; i < l; ++i) {\n            if (lib.isSeq(seq, view, offset + i)) { return offset + i; }\n        }\n        return -1;\n    };\n\n    lib.locateStrTrm = {\n        // Locate the first occurrence of non-Unicode null-terminator (i.e. a single zeroed-out\n        //  octet) in DataView `view`. Search starts at given `offset` and ends after `length`\n        //  octets. Will return the absolute offset of sequence if found, -1 otherwise\n        iso: function (view, offset, length) {\n            return lib.locateSeq([0], view, offset, length);\n        },\n\n        // Locate the first occurrence of Unicode null-terminator (i.e. a sequence of two\n        //  zeroed-out octets) in DataView `view`. Search starts at given `offset` and ends after\n        //  `length` octets. Will return the absolute offset of sequence if found, -1 otherwise\n        ucs: function (view, offset, length) {\n            var trmOffset = lib.locateSeq([0, 0], view, offset, length);\n            if (trmOffset === -1) { return -1; }\n            if ((trmOffset - offset) % 2 !== 0) { ++trmOffset; }\n            return trmOffset;\n        }\n    };\n\n    lib.readStr = {\n        // Parse DataView `view` begining at `offset` index and return a string built from\n        //  `length` octets. The view is parsed as an array of 8bit single-byte coded characters\n        //  (i.e. ISO/IEC 8859-1, _non_ Unicode). Will essentially return the string comprised of\n        //  octets [offset, offset + length). Note that no check is performed for the adequate\n        //  length of given view as this should be carried out be the caller as part of the\n        //  section-parsing process\n        iso: function (view, offset, length) {\n            return String.fromCharCode.apply(null, new Uint8Array(view.buffer, offset, length));\n        },\n\n        // UCS-2 (ISO/IEC 10646-1:1993, UCS-2) version of `readStr`. UCS-2 is the fixed-width\n        //  two-byte subset of Unicode that can only express values inside the Basic Multilingual\n        //  Plane (BMP). Note that this method is generally unsuitable for parsing non-trivial\n        //  UTF-16 strings which may contain surrogate pairs. [This is only marginally related\n        //  though as, according to ID3v2, all Unicode strings should be UCS-2.] Further info:\n        //\n        //  * [How to convert ArrayBuffer to and from String](http://updates.html5rocks.com/2012/06/How-to-convert-ArrayBuffer-to-and-from-String)\n        //  * [The encoding spec](http://encoding.spec.whatwg.org/)\n        //  * [stringencoding shim](https://code.google.com/p/stringencoding/)\n        //\n        // About the BOM: The current implementation will check for and remove the leading BOM from\n        //  the given view to avoid invisible characters that mess up the resulting strings. MDN's\n        //  documentation for [fromCharCode](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode)\n        //  suggests that it can correctly convert UCS-2 buffers to strings. And indeed, tests\n        //  performed with UCS-2 LE encoded frames indicate that it does. However, no tests have\n        //  been made for UCS-2 BE. (Kid3, the ID3v2 Tag generator used for tests at the time of\n        //  this writing, goes totally weird when switched to BE)\n        ucs: function (view, offset, length) {\n            // Tweak offset to remove the BOM (LE: FF FE / BE: FE FF)\n            if (view.getUint16(offset) === 0xFFFE || view.getUint16(offset) === 0xFEFF) {\n                offset += 2;\n                length -= 2;\n            }\n\n            var buffer = view.buffer;\n\n            // When offset happens to be an even number of octets, the array-buffer may be wrapped\n            //  in a Uint16Array. In the event that it's _not_, an actual copy has to be made\n            // (Note that Node <= 0.8 as well as IE <= 10 lack an ArrayBuffer#slice. TODO: shim it)\n            if (offset % 2 === 1) {\n                buffer = buffer.slice(offset, offset + length);\n                offset = 0;\n            }\n\n            return String.fromCharCode.apply(null, new Uint16Array(buffer, offset, length / 2));\n        }\n    };\n\n    lib.readTrmStr = {\n        // Similar to `readStr.iso` but will check for a null-terminator determining the end of the\n        //  string. The returned string will be of _at most_ `length` octets\n        iso: function (view, offset, length) {\n            var trmOffset = lib.locateStrTrm.iso(view, offset, length);\n            if (trmOffset !== -1) { length = trmOffset - offset; }\n            return lib.readStr.iso(view, offset, length);\n        },\n\n        // Similar to `readStr.ucs` but will check for a null-terminator determining the end of the\n        //  string. The returned string will be of _at most_ `length` octets\n        ucs: function (view, offset, length) {\n            var trmOffset = lib.locateStrTrm.ucs(view, offset, length);\n            if (trmOffset !== -1) { length = trmOffset - offset; }\n            return lib.readStr.ucs(view, offset, length);\n        }\n    };\n\n    // ### Read a Frame Header\n    //\n    // Read header of frame located at `offset` of DataView `view`. Returns null in the event\n    //  that no frame header is found at `offset`\n    lib.readFrameHeader = function (view, offset) {\n        offset || (offset = 0);\n\n        // There should be more than 4 octets ahead\n        if (view.byteLength - offset <= 4) { return null; }\n\n        // Header's first (out of four) octet: `11111111`: Frame sync (all bits must be set)\n        var b1 = view.getUint8(offset);\n        if (b1 !== 255) { return null; }\n\n        // Header's second (out of four) octet: `111xxxxx`\n        //\n        // * `111.....`: Rest of frame sync (all bits must be set)\n        // * `...BB...`: MPEG Audio version ID (11 -> MPEG Version 1 (ISO/IEC 11172-3))\n        // * `.....CC.`: Layer description (01 -> Layer III)\n        // * `.......1`: Protection bit (1 = Not protected)\n\n        // Require the three most significant bits to be `111` (>= 224)\n        var b2 = view.getUint8(offset + 1);\n        if (b2 < 224) { return null; }\n\n        var mpegVersion = octetToBinRep(b2).substr(3, 2);\n        var layerVersion = octetToBinRep(b2).substr(5, 2);\n\n        //\n        var header = {\n            _section: { type: \"frameHeader\", byteLength: 4, offset: offset },\n            mpegAudioVersionBits: mpegVersion,\n            mpegAudioVersion: lib.mpegVersionDescription[mpegVersion],\n            layerDescriptionBits: layerVersion,\n            layerDescription: lib.layerDescription[layerVersion],\n            isProtected: b2 & 1, // Just check if last bit is set\n        };\n        header.protectionBit = header.isProtected ? \"1\" : \"0\";\n\n        if (header.mpegAudioVersion === \"reserved\") { return null; }\n        if (header.layerDescription === \"reserved\") { return null; }\n\n        // Header's third (out of four) octet: `EEEEFFGH`\n        //\n        // * `EEEE....`: Bitrate index. 1111 is invalid, everything else is accepted\n        // * `....FF..`: Sampling rate, 00=44100, 01=48000, 10=32000, 11=reserved\n        // * `......G.`: Padding bit, 0=frame not padded, 1=frame padded\n        // * `.......H`: Private bit. This is informative\n        var b3 = view.getUint8(offset + 2);\n        b3 = octetToBinRep(b3);\n        header.bitrateBits = b3.substr(0, 4);\n        header.bitrate = lib.bitrateMap[mpegVersion][layerVersion][header.bitrateBits];\n        if (header.bitrate === \"bad\") { return null; }\n\n        header.samplingRateBits = b3.substr(4, 2);\n        header.samplingRate = lib.samplingRateMap[mpegVersion][header.samplingRateBits];\n        if (header.samplingRate === \"reserved\") { return null; }\n\n        header.frameIsPaddedBit = b3.substr(6, 1);\n        header.frameIsPadded = header.frameIsPaddedBit === \"1\";\n        header.framePadding = header.frameIsPadded ? 1 : 0;\n\n        header.privateBit = b3.substr(7, 1);\n\n        // Header's fourth (out of four) octet: `IIJJKLMM`\n        //\n        // * `II......`: Channel mode\n        // * `..JJ....`: Mode extension (only if joint stereo)\n        // * `....K...`: Copyright\n        // * `.....L..`: Original\n        // * `......MM`: Emphasis\n        var b4 = view.getUint8(offset + 3);\n        header.channelModeBits = octetToBinRep(b4).substr(0, 2);\n        header.channelMode = lib.channelModes[header.channelModeBits];\n\n        return header;\n    };\n\n    // ### Read a Frame\n    //\n    // Read frame located at `offset` of DataView `view`. Will acquire the frame header (see\n    //  `readFrameHeader`) plus some basic information about the frame - notably the frame's length\n    //  in bytes. If `requireNextFrame` is set, the presence of a _next_ valid frame will be\n    //  required for _this_ frame to be regarded as valid. Returns null in the event that no frame\n    //  is found at `offset`\n    lib.readFrame = function (view, offset, requireNextFrame) {\n        offset || (offset = 0);\n\n        var frame = {\n            _section: { type: \"frame\", offset: offset },\n            header: lib.readFrameHeader(view, offset)\n        };\n\n        var head = frame.header; // Convenience shortcut\n\n        // Frame should always begin with a valid header\n        if (!head) { return null; }\n\n        frame._section.sampleLength =\n            lib.sampleLengthMap[head.mpegAudioVersionBits][head.layerDescriptionBits];\n\n        //\n        frame._section.byteLength = lib.getFrameByteLength(head.bitrate, head.samplingRate,\n            head.framePadding, head.mpegAudioVersionBits, head.layerDescriptionBits);\n        frame._section.nextFrameIndex = offset + frame._section.byteLength;\n\n        // No \"Xing\" or \"Info\" identifier should be present - this would indicate that this\n        //  is in fact a Xing tag masquerading as a frame\n        var xingOffset = lib.getXingOffset(head.mpegAudioVersionBits, head.channelModeBits);\n        if (lib.isSeq(lib.seq.xing, view, offset + xingOffset) ||\n            lib.isSeq(lib.seq.info, view, offset + xingOffset)) {\n            return null;\n        }\n\n        // If a next frame is required then the data at `frame._section.nextFrameIndex` should be\n        //  a valid frame header\n        if (requireNextFrame && !lib.readFrameHeader(view, frame._section.nextFrameIndex)) {\n            return null;\n        }\n\n        return frame;\n    };\n}));\n","//     mp3-parser/id3v2 v0.3.0\n\n//     https://github.com/biril/mp3-parser\n//     Licensed and freely distributed under the MIT License\n//     Copyright (c) 2013-2016 Alex Lambiris\n\n// ----\n\n/* jshint browser:true */\n/* global exports:false, define:false, require:false */\n(function (globalObject, createModule) {\n    \"use strict\";\n\n    // Export as a module or global depending on environment:\n\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\n    if (typeof define === \"function\" && define.amd) {\n        return define([\"exports\", \"./lib\"], createModule);\n    }\n\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\n    if (typeof exports === \"object\") {\n        return createModule(exports, require(\"./lib\"));\n    }\n\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\n    var previousMp3Id3v2Parser = globalObject.mp3Id3v2Parser;\n    createModule(globalObject.mp3Id3v2Parser = {\n        noConflict: function () {\n            var mp3Id3v2Parser = globalObject.mp3Id3v2Parser;\n            globalObject.mp3Id3v2Parser = previousMp3Id3v2Parser;\n            return (this.noConflict = function () { return mp3Id3v2Parser; }).call();\n        }\n    }, globalObject.mp3ParserLib);\n}(this, function (mp3Id3v2Parser, lib) {\n    \"use strict\";\n\n    //\n    var id3v2TagFrameNames = {\n        AENC: \"Audio encryption\",\n        APIC: \"Attached picture\",\n        CHAP: \"Chapter\",\n        COMM: \"Comments\",\n        COMR: \"Commercial frame\",\n        ENCR: \"Encryption method registration\",\n        EQUA: \"Equalization\",\n        ETCO: \"Event timing codes\",\n        GEOB: \"General encapsulated object\",\n        GRID: \"Group identification registration\",\n        IPLS: \"Involved people list\",\n        LINK: \"Linked information\",\n        MCDI: \"Music CD identifier\",\n        MLLT: \"MPEG location lookup table\",\n        OWNE: \"Ownership frame\",\n        PRIV: \"Private frame\",\n        PCNT: \"Play counter\",\n        POPM: \"Popularimeter\",\n        POSS: \"Position synchronisation frame\",\n        RBUF: \"Recommended buffer size\",\n        RVAD: \"Relative volume adjustment\",\n        RVRB: \"Reverb\",\n        SYLT: \"Synchronized lyric/text\",\n        SYTC: \"Synchronized tempo codes\",\n        TALB: \"Album/Movie/Show title\",\n        TBPM: \"BPM (beats per minute)\",\n        TCOM: \"Composer\",\n        TCON: \"Content type\",\n        TCOP: \"Copyright message\",\n        TDAT: \"Date\",\n        TDLY: \"Playlist delay\",\n        TENC: \"Encoded by\",\n        TEXT: \"Lyricist/Text writer\",\n        TFLT: \"File type\",\n        TIME: \"Time\",\n        TIT1: \"Content group description\",\n        TIT2: \"Title/songname/content description\",\n        TIT3: \"Subtitle/Description refinement\",\n        TKEY: \"Initial key\",\n        TLAN: \"Language(s)\",\n        TLEN: \"Length\",\n        TMED: \"Media type\",\n        TOAL: \"Original album/movie/show title\",\n        TOFN: \"Original filename\",\n        TOLY: \"Original lyricist(s)/text writer(s)\",\n        TOPE: \"Original artist(s)/performer(s)\",\n        TORY: \"Original release year\",\n        TOWN: \"File owner/licensee\",\n        TPE1: \"Lead performer(s)/Soloist(s)\",\n        TPE2: \"Band/orchestra/accompaniment\",\n        TPE3: \"Conductor/performer refinement\",\n        TPE4: \"Interpreted, remixed, or otherwise modified by\",\n        TPOS: \"Part of a set\",\n        TPUB: \"Publisher\",\n        TRCK: \"Track number/Position in set\",\n        TRDA: \"Recording dates\",\n        TRSN: \"Internet radio station name\",\n        TRSO: \"Internet radio station owner\",\n        TSIZ: \"Size\",\n        TSRC: \"ISRC (international standard recording code)\",\n        TSSE: \"Software/Hardware and settings used for encoding\",\n        TYER: \"Year\",\n        TXXX: \"User defined text information frame\",\n        UFID: \"Unique file identifier\",\n        USER: \"Terms of use\",\n        USLT: \"Unsychronized lyric/text transcription\",\n        WCOM: \"Commercial information\",\n        WCOP: \"Copyright/Legal information\",\n        WOAF: \"Official audio file webpage\",\n        WOAR: \"Official artist/performer webpage\",\n        WOAS: \"Official audio source webpage\",\n        WORS: \"Official internet radio station homepage\",\n        WPAY: \"Payment\",\n        WPUB: \"Publishers official webpage\",\n        WXXX: \"User defined URL link frame\"\n    };\n\n    //\n    var readFrameContent = {};\n\n    // Read the content of a\n    //  [text-information frame](http://id3.org/id3v2.3.0#Text_information_frames). These are\n    //  common and contain info such as artist and album. There may only be one text info frame\n    //  of its kind in a tag. If the textstring is followed by a termination (00) all the\n    //  following information should be ignored and not be displayed. All text frame\n    //  identifiers begin with \"T\". Only text frame identifiers begin with \"T\", with the\n    //  exception of the \"TXXX\" frame\n    //\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * Information: a text string according to encoding\n    readFrameContent.T = function (view, offset, length) {\n        var content = { encoding: view.getUint8(offset) };\n        content.value = lib.readStr[content.encoding === 0 ? \"iso\" : \"ucs\"](\n            view, offset + 1, length - 1);\n        return content;\n    };\n\n    // Read the content of a\n    //  [user-defined text-information frame](http://id3.org/id3v2.3.0#User_defined_text_information_frame).\n    //  Intended for one-string text information concerning the audiofile in a similar way to\n    //  the other \"T\"-frames. The frame body consists of a description of the string,\n    //  represented as a terminated string, followed by the actual string. There may be more\n    //  than one \"TXXX\" frame in each tag, but only one with the same description\n    //\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * Description: a text string according to encoding (followed by 00 (00))\n    // * Value:       a text string according to encoding\n    readFrameContent.TXXX = function  (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Encoding + null term. = at least 2 octets\n        if (length < 2) {\n            return content; // Inadequate length!\n        }\n\n        // Encoding and content beginning (description field)\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        var offsetBeg = offset + 1;\n\n        // Locate the the null terminator seperating description and URL\n        var offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, length - 4);\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read description and value data into content\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\n        offsetTrm += enc === \"ucs\" ? 2 : 1; // Move past terminating sequence\n        content.value = lib.readStr[enc](view, offsetTrm, offset + length - offsetTrm);\n\n        return content;\n    };\n\n    // Read the content of a\n    //  [URL-link frame](http://id3.org/id3v2.3.0#URL_link_frames). There may only be one\n    //  URL link frame of its kind in a tag, except when stated otherwise in the frame\n    //  description. If the textstring is followed by a termination (00) all the following\n    //  information should be ignored and not be displayed. All URL link frame identifiers\n    //  begins with \"W\". Only URL link frame identifiers begins with \"W\"\n    //\n    // * URL: a text string\n    readFrameContent.W = function (view, offset, length) {\n        return { value: lib.readStr.iso(view, offset, length) };\n    };\n\n    // Read the content of a\n    //  [user-defined URL-link frame](http://id3.org/id3v2.3.0#User_defined_URL_link_frame).\n    //  Intended for URL links concerning the audiofile in a similar way to the other\n    //  \"W\"-frames. The frame body consists of a description of the string, represented as a\n    //  terminated string, followed by the actual URL. The URL is always encoded with\n    //  ISO-8859-1. There may be more than one \"WXXX\" frame in each tag, but only one with the\n    //  same description\n    //\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * Description: a text string according to encoding (followed by 00 (00))\n    // * URL:         a text string\n    readFrameContent.WXXX = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Encoding + null term. = at least 2 octets\n        if (length < 2) {\n            return content; // Inadequate length!\n        }\n\n        // Encoding and content beginning (description field)\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        var offsetBeg = offset + 1;\n\n        // Locate the the null terminator seperating description and URL\n        var offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, length - 4);\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read description and value data into content\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\n        offsetTrm += enc === \"ucs\" ? 2 : 1; // Move past terminating sequence\n        content.value = lib.readStr.iso(view, offsetTrm, offset + length - offsetTrm);\n\n        return content;\n    };\n\n    // Read the content of a [comment frame](http://id3.org/id3v2.3.0#Comments).\n    //  Intended for any kind of full text information that does not fit in any other frame.\n    //  Consists of a frame header followed by encoding, language and content descriptors and\n    //  ends with the actual comment as a text string. Newline characters are allowed in the\n    //  comment text string. There may be more than one comment frame in each tag, but only one\n    //  with the same language and content descriptor. [Note that the structure of comment\n    //  frames is identical to that of USLT frames - `readFrameContentComm` will handle both.]\n    //\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * Language:    3 digit (octet) lang-code (ISO-639-2)\n    // * Short descr: a text string according to encoding (followed by 00 (00))\n    // * Actual text: a text string according to encoding\n    readFrameContent.COMM = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Encoding + language + null term. = at least 5 octets\n        if (length < 5) {\n            return content; // Inadequate length!\n        }\n\n        // Encoding and content beggining (short description field)\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        var offsetBeg = offset + 4;\n\n        // Read the language field - 3 octets at most\n        content.language = lib.readTrmStr.iso(view, offset + 1, 3);\n\n        // Locate the the null terminator seperating description and text\n        var offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, length - 4);\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read short description and text data into content\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\n        offsetTrm += enc === \"ucs\" ? 2 : 1; // Move past terminating sequence\n        content.text = lib.readStr[enc](view, offsetTrm, offset + length - offsetTrm);\n\n        return content;\n    };\n\n    // Read the content of a\n    //  [unique file identifier frame](http://id3.org/id3v2.3.0#Unique_file_identifier). Allows\n    //  identification of the audio file by means of some database that may contain more\n    //  information relevant to the content. Begins with a URL containing an email address, or\n    //  a link to a location where an email address can be found that belongs to the\n    //  organisation responsible for this specific database implementation. The 'Owner\n    //  identifier' must be non-empty (more than just a termination) and is followed by the\n    //  actual identifier, which may be up to 64 bytes. There may be more than one \"UFID\" frame\n    //  in a tag, but only one with the same 'Owner identifier'. Note that this frame is very\n    //  similar to the \"PRIV\" frame\n    //\n    // * Owner identifier: a text string (followed by 00)\n    // * Identifier:       up to 64 bytes of binary data\n    readFrameContent.UFID = function (view, offset, length) {\n        // Read up to the first null terminator to get the owner-identifier\n        var ownerIdentifier = lib.readTrmStr.iso(view, offset, length);\n\n        // Figure out the identifier based on frame length vs owner-identifier length\n        var identifier = new DataView(view.buffer, offset + ownerIdentifier.length + 1,\n            length - ownerIdentifier.length - 1);\n\n        return { ownerIdentifier: ownerIdentifier, identifier: identifier };\n    };\n\n    // Read the content of an\n    //  [involved people list frame](http://id3.org/id3v2.3.0#Involved_people_list). Contains\n    //  names of those involved - those contributing to the audio file - and how they were\n    //  involved. The body simply contains the first 'involvement' as a terminated string, directly\n    //  followed by the first 'involvee' as a terminated string, followed by a second terminated\n    //  involvement string and so on. However, in the current implementation the frame's content is\n    //  parsed as a collection of strings without any semantics attached. There may only be one\n    //  \"IPLS\" frame in each tag\n    //\n    // * Encoding:            a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * People list strings: a series of strings, e.g. string 00 (00) string 00 (00) ..\n    readFrameContent.IPLS = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset), values: [] };\n\n        // Encoding and content beginning (people list - specifically, first 'involvement' string)\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        var offsetBeg = offset + 1;\n\n        // Index of null-terminator found within people list (seperates involvement / involvee)\n        var offsetNextStrTrm;\n\n        while (offsetBeg < offset + length) {\n            // We expect all strings within the people list to be null terminated ..\n            offsetNextStrTrm = lib.locateStrTrm[enc](view, offsetBeg, length - (offsetBeg - offset));\n\n            // .. except _perhaps_ the last one. In this case fix the offset at the frame's end\n            if (offsetNextStrTrm === -1) {\n                offsetNextStrTrm = offset + length;\n            }\n\n            content.values.push(lib.readStr[enc](view, offsetBeg, offsetNextStrTrm - offsetBeg));\n            offsetBeg = offsetNextStrTrm + (enc === \"ucs\" ? 2 : 1);\n        }\n\n        return content;\n    };\n\n    // Read the content of a [terms of use frame](http://id3.org/id3v2.3.0#Terms_of_use_frame).\n    //  Contains a description of the terms of use and ownership of the file. Newlines are\n    //  allowed in the text. There may only be one \"USER\" frame in a tag.\n    //\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * Language:    3 digit (octet) lang-code (ISO-639-2)\n    // * Actual text: a text string according to encoding\n    readFrameContent.USER = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Encoding + language + null term. = at least 5 octets\n        if (length < 5) {\n            return content; // Inadequate length!\n        }\n\n        // Read the language field - 3 octets at most\n        content.language = lib.readTrmStr.iso(view, offset + 1, 3);\n\n        // Read the text field\n        var offsetBeg = offset + 4;\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        content.text = lib.readStr[enc](view, offsetBeg, offset + length - offsetBeg);\n\n        return content;\n    };\n\n    // Read the content of a\n    //  [private frame](http://id3.org/id3v2.3.0#Private_frame). Contains binary data that does\n    //  no fit into the other frames. Begins with a URL containing an email address, or\n    //  a link to a location where an email address can be found. The 'Owner identifier' must\n    //  be non-empty (more than just a termination) and is followed by the actual data. There\n    //  may be more than one \"PRIV\" frame in a tag, but only with different contents. Note that\n    //  this frame is very similar to the \"UFID\" frame\n    //\n    // * Owner identifier: a text string (followed by 00)\n    // * private data:     binary data (of unbounded length)\n    readFrameContent.PRIV = function (view, offset, length) {\n        // Read up to the first null terminator to get the owner-identifier\n        var ownerIdentifier = lib.readTrmStr.iso(view, offset, length);\n\n        // Figure out the private data based on frame length vs owner-identifier length\n        var privateData = new DataView(view.buffer, offset + ownerIdentifier.length + 1,\n            length - ownerIdentifier.length - 1);\n\n        return { ownerIdentifier: ownerIdentifier, privateData: privateData };\n    };\n\n    // Read the content of a [play counter](http://id3.org/id3v2.3.0#Play_counter). A counter\n    //  of the number of times a file has been played. There may only be one \"PCNT\" frame in a\n    //  tag. [According to the standard, \"When the counter reaches all one's, one byte is\n    //  inserted in front of the counter thus making the counter eight bits bigger.\" This is\n    //  not currently taken into account]\n    //\n    // * Counter: 4 octets (at least ..)\n    readFrameContent.PCNT = function (view, offset, length) {\n        // The counter must be at least 4 octets long to begin with\n        if (length < 4) {\n            return {}; // Inadequate length!\n        }\n\n        // Assume the counter is always exactly 4 octets ..\n        return { counter: view.getUint32(offset) };\n    };\n\n    // Read the content of a [popularimeter](http://id3.org/id3v2.3.0#Popularimeter). Intended\n    //  as a measure for the file's popularity, it contains a user's email address, one rating\n    //  octet and a four octer play counter, intended to be increased with one for every time\n    //  the file is played. If no personal counter is wanted it may be omitted. [As is the case\n    //  for the \"PCNT\" frame, according to the standard, \"When the counter reaches all one's,\n    //  one byte is inserted in front of the counter thus making the counter eight bits\n    //  bigger.\" This is not currently taken into account]. There may be more than one \"POPM\"\n    //  frame in each tag, but only one with the same email address\n    //\n    // * Email to user: a text string (followed by 00)\n    // * Rating:        a single octet, values in 0-255 (0 = unknown, 1 = worst, 255 = best)\n    // * Counter:       4 octets (at least ..)\n    readFrameContent.POPM = function (view, offset, length) {\n        var content = {\n                email: lib.readTrmStr.iso(view, offset, length)\n            };\n\n        // rating offset\n        offset += content.email.length + 1;\n\n        // email str term + rating + counter = at least 6 octets\n        if (length < 6) {\n            return content; // Inadequate length!\n        }\n\n        content.rating = view.getUint8(offset);\n\n        // Assume the counter is always exactly 4 octets ..\n        content.counter = view.getUint32(offset + 1);\n\n        return content;\n    };\n\n    // Read the content of an [attached picture](http://id3.org/id3v2.3.0#Attached_picture).\n    //  Contains a picture directly related to the audio file. In the event that the MIME media\n    //  type name is omitted, \"image/\" will be implied. The description has a maximum length of\n    //  64 characters, but may be empty. There may be several pictures attached to one file,\n    //  each in their individual \"APIC\" frame, but only one with the same content descriptor.\n    //  There may only be one picture with the picture type declared as picture type $01 and\n    //  $02 respectively.\n    //\n    // * Encoding:     a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * MIME Type:    a text string (followed by 00) - MIME type and subtype of image\n    // * Picture type: a single octet, values in 0-255: a type-id as given by the standard\n    // * Description:  a text string according to encoding (followed by 00 (00))\n    // * Picture data: binary data (of unbounded length)\n    readFrameContent.APIC = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Encoding + MIME type string term + pic type octet + descr. string term = min 4 octets\n        if (length < 4) {\n            return content; // Inadequate length!\n        }\n\n        // Encoding and offsets of content beginning / null-terminator\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        var offsetBeg, offsetTrm;\n\n        // Locate the the null terminator seperating MIME type and picture type\n        offsetBeg = offset + 1; // After the encoding octet\n        offsetTrm = lib.locateStrTrm.iso(view, offsetBeg, length - 1);\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read MIME type\n        content.mimeType = lib.readStr.iso(view, offsetBeg, offsetTrm - offsetBeg);\n\n        // Read picture type\n        offsetBeg = offsetTrm + 1;\n        content.pictureType = view.getUint8(offsetBeg);\n\n        // Locate the the null terminator seperating description and picture data\n        offsetBeg += 1;\n        offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, offset + length - offsetBeg);\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read description\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\n\n        // Read picture data\n        offsetBeg = offsetTrm + (enc === \"ucs\" ? 2 : 1);\n        content.pictureData = new DataView(view.buffer, offsetBeg, offset + length - offsetBeg);\n\n        return content;\n    };\n\n    // Read the chapter tag according to the ID3v2 Chapter Frame Addendum (http://id3.org/id3v2-chapters-1.0)\n    //  The frame contains subframes, typically TIT2, and possibly additional frames\n    //\n    // * Id:            string identifier of the chapter\n    // * Start time:    4 octets specifying the start of the chapter in milliseconds\n    // * End time:      4 octets specifying the end of the chapter in milliseconds\n    // * Start offset:  4 octets specifying the start of the chapter in bytes\n    // * End offset:    4 octets specifying the end of the chapter in bytes\n    // * Frames:        nested id3v2 frames\n    readFrameContent.CHAP = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Locate the the null terminator between id and start time\n        var offsetTrm = lib.locateStrTrm.iso(view, offset, length - 1);\n\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read id\n        content.id = lib.readStr.iso(view, offset, offsetTrm - offset);\n\n        // Read start time\n        content.startTime = view.getUint32(offsetTrm + 1);\n\n        // Read end time\n        content.endTime = view.getUint32(offsetTrm + 5);\n\n        // Read start offset\n        content.startOffset = view.getUint32(offsetTrm + 9);\n\n        // Read end offset\n        content.endOffset = view.getUint32(offsetTrm + 13);\n\n        var offsetSubFrames = offsetTrm + 17;\n        content.frames = [];\n        while (offsetSubFrames < offset + length) {\n            var subFrame = mp3Id3v2Parser.readId3v2TagFrame(view, offsetSubFrames);\n            content.frames.push(subFrame);\n            offsetSubFrames += subFrame.header.size + 10;\n        }\n\n        return content;\n    };\n\n    // ### Read an ID3v2 Tag Frame\n    //\n    // Read [ID3v2 Tag frame](http://id3.org/id3v2.3.0#Declared_ID3v2_frames) located at `offset`\n    //  of DataView `view`. Returns null in the event that no tag-frame is found at `offset`\n    mp3Id3v2Parser.readId3v2TagFrame = function (view, offset) {\n        // All frames consist of a frame header followed by one or more fields containing the actual\n        // information. The frame header is 10 octets long and laid out as `IIIISSSSFF`, where\n        //\n        // * `IIII......`: Frame id (four characters)\n        // * `....SSSS..`: Size (frame size excluding frame header = frame size - 10)\n        // * `........FF`: Flags\n        var frame = {\n            header: {\n                id: lib.readStr.iso(view, offset, 4),\n                size: view.getUint32(offset + 4),\n                flagsOctet1: view.getUint8(offset + 8),\n                flagsOctet2: view.getUint8(offset + 9)\n            }\n        };\n\n        // An ID3v2 tag frame must have a length of at least 1 octet, excluding the header\n        if (frame.header.size < 1) { return frame; }\n\n        // A function to read the frame's content\n        var readContent = (function (read, id) { // jscs:disable requirePaddingNewLinesBeforeLineComments\n            // User-defined text-information frames\n            if (id === \"TXXX\") { return read.TXXX; }\n            // Text-information frames\n            if (id.charAt(0) === \"T\") { return read.T; }\n            // User-defined URL-link frames\n            if (id === \"WXXX\") { return read.WXXX; }\n            // URL-link frames\n            if (id.charAt(0) === \"W\") { return read.W; }\n            // Comment frames or Unsychronised lyrics/text transcription frames\n            if (id === \"COMM\" || id === \"USLT\") { return read.COMM; }\n            // For any other frame such as UFID, IPLS, USER, etc, return the reader function\n            //  that's named after the frame. Return a 'no-op reader' (which just returns\n            //  `undefined` as the frame's content) if no implementation found for given frame\n            return read[id] || lib.noOp;\n        }(readFrameContent, frame.header.id)); // jscs-enable requirePaddingNewLinesBeforeLineComments\n\n        // Store frame's friendly name\n        frame.name = id3v2TagFrameNames[frame.header.id];\n\n        // Read frame's content\n        frame.content = readContent(view, offset + 10, frame.header.size);\n\n        return frame;\n    };\n\n    // ### Read the ID3v2 Tag\n    //\n    // Read [ID3v2 Tag](http://id3.org/id3v2.3.0) located at `offset` of DataView `view`. Returns\n    //  null in the event that no tag is found at `offset`\n    mp3Id3v2Parser.readId3v2Tag = function (view, offset) {\n        offset || (offset = 0);\n\n        // The ID3v2 tag header, which should be the first information in the file, is 10 octets\n        //  long and laid out as `IIIVVFSSSS`, where\n        //\n        // * `III.......`: id, always \"ID3\" (0x49/73, 0x44/68, 0x33/51)\n        // * `...VV.....`: version (major version + revision number)\n        // * `.....F....`: flags: abc00000. a:unsynchronisation, b:extended header, c:experimental\n        // * `......SSSS`: tag's size as a synchsafe integer\n\n        // There should be at least 10 bytes ahead\n        if (view.byteLength - offset < 10) { return null; }\n\n        // The 'ID3' identifier is expected at given offset\n        if (!lib.isSeq(lib.seq.id3, view, offset)) { return null; }\n\n        //\n        var flagsOctet = view.getUint8(offset + 5);\n\n        //\n        var tag = {\n            _section: { type: \"ID3v2\", offset: offset },\n            header: {\n                majorVersion: view.getUint8(offset + 3),\n                minorRevision: view.getUint8(offset + 4),\n                flagsOctet: flagsOctet,\n                unsynchronisationFlag: (flagsOctet & 128) === 128,\n                extendedHeaderFlag: (flagsOctet & 64) === 64,\n                experimentalIndicatorFlag: (flagsOctet & 32) === 32,\n                size: lib.unsynchsafe(view.getUint32(offset + 6))\n            },\n            frames: []\n        };\n\n        // The size as expressed in the header is the size of the complete tag after\n        //  unsychronisation, including padding, excluding the header but not excluding the\n        //  extended header (total tag size - 10)\n        tag._section.byteLength = tag.header.size + 10;\n\n        // Index of octet following tag's last octet: The tag spans [offset, tagEnd)\n        //  (including the first 10 header octets)\n        var tagEnd = offset + tag._section.byteLength;\n\n        // TODO: Process extended header if present. The presence of an extended header will affect\n        //  the offset. Currently, it is asummed that no extended header is present so the offset\n        //  is fixed at 10 octets\n        // if (tag.header.extendedHeaderFlag) { /* TODO */ }\n\n        // Go on to read individual frames but only if the tag version is v2.3. This is the only\n        //  version currently supported\n        if (tag.header.majorVersion !== 3) { return tag; }\n\n        // To store frames as they're discovered while paring the tag\n        var frame;\n\n        // Move offset past the end of the tag header to start reading tag frames\n        offset += 10;\n        while (offset < tagEnd) {\n            // Locating a frame with a zeroed out id indicates that all valid frames have already\n            //  been parsed. It's all dead space hereon so practically we're done\n            if (view.getUint32(offset) === 0) { break; }\n\n            frame = mp3Id3v2Parser.readId3v2TagFrame(view, offset);\n\n            // Couldn't parse this frame so bail out\n            if (!frame) { break; }\n\n            tag.frames.push(frame);\n            offset += frame.header.size + 10;\n        }\n\n        return tag;\n    };\n}));\n","//     mp3-parser/xing v0.3.0\n\n//     https://github.com/biril/mp3-parser\n//     Licensed and freely distributed under the MIT License\n//     Copyright (c) 2013-2016 Alex Lambiris\n\n// ----\n\n/* jshint browser:true */\n/* global exports:false, define:false, require:false */\n(function (globalObject, createModule) {\n    \"use strict\";\n\n    // Export as a module or global depending on environment:\n\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\n    if (typeof define === \"function\" && define.amd) {\n        return define([\"exports\", \"./lib\"], createModule);\n    }\n\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\n    if (typeof exports === \"object\") {\n        return createModule(exports, require(\"./lib\"));\n    }\n\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\n    var previousMp3XingParser = globalObject.mp3XingParser;\n    createModule(globalObject.mp3XingParser = {\n        noConflict: function () {\n            var mp3XingParser = globalObject.mp3XingParser;\n            globalObject.mp3XingParser = previousMp3XingParser;\n            return (this.noConflict = function () { return mp3XingParser; }).call();\n        }\n    }, globalObject.mp3ParserLib);\n}(this, function (xingParser, lib) {\n    \"use strict\";\n\n    // ### Read the Xing Tag\n    //\n    // Read [Xing / Lame Tag](http://gabriel.mp3-tech.org/mp3infotag.html) located at `offset` of\n    //  DataView `view`. Returns null in the event that no frame is found at `offset`\n    xingParser.readXingTag = function (view, offset) {\n        offset || (offset = 0);\n\n        var tag = {\n            _section: { type: \"Xing\", offset: offset },\n            header: lib.readFrameHeader(view, offset)\n        };\n\n        var head = tag.header; // Convenience shortcut\n\n        // The Xing tag should begin with a valid frame header\n        if (!head) { return null; }\n\n        var xingOffset = offset +\n            lib.getXingOffset(head.mpegAudioVersionBits, head.channelModeBits);\n\n        // There should be at least 'offset' (header) + 4 (\"Xing\"/\"Info\") octets ahead\n        if (view.byteLength < xingOffset + 4) { return null; }\n\n        // A \"Xing\" or \"Info\" identifier should be present\n        tag.identifier = (lib.isSeq(lib.seq.xing, view, xingOffset) && \"Xing\") ||\n            (lib.isSeq(lib.seq.info, view, xingOffset) && \"Info\");\n        if (!tag.identifier) { return null; }\n\n        //\n        tag._section.byteLength = lib.getFrameByteLength(head.bitrate, head.samplingRate,\n            head.framePadding, head.mpegAudioVersionBits, head.layerDescriptionBits);\n        tag._section.nextFrameIndex = offset + tag._section.byteLength;\n\n        return tag;\n    };\n}));\n","//     mp3-parser v0.3.0\n\n//     https://github.com/biril/mp3-parser\n//     Licensed and freely distributed under the MIT License\n//     Copyright (c) 2013-2016 Alex Lambiris\n\n// ----\n\n/* jshint browser:true */\n/* global exports:false, define:false, require:false */\n(function (globalObject, createModule) {\n    \"use strict\";\n\n    // Export as a module or global depending on environment:\n\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\n    if (typeof define === \"function\" && define.amd) {\n        return define([\"exports\", \"./lib/lib\", \"./lib/id3v2\", \"./lib/xing\"], createModule);\n    }\n\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\n    if (typeof exports === \"object\") {\n        return createModule(exports, require(\"./lib/lib\"), require(\"./lib/id3v2\"),\n            require(\"./lib/xing\"));\n    }\n\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\n    var previousMp3Parser = globalObject.mp3Parser;\n    createModule(globalObject.mp3Parser = {\n        noConflict: function () {\n            var mp3Parser = globalObject.mp3Parser;\n            globalObject.mp3Parser = previousMp3Parser;\n            return (this.noConflict = function () { return mp3Parser; }).call();\n        }\n    }, globalObject.mp3ParserLib, globalObject.mp3Id3v2Parser, globalObject.mp3XingParser);\n}(this, function (mp3Parser, lib, id3v2Parser, xingParser) {\n    \"use strict\";\n\n    // ### TL;DR\n    //\n    // The parser exposes a collection of `read____` methods, each dedicated to reading a specific\n    //  section of the mp3 file. The current implementation includes `readFrameHeader`, `readFrame`,\n    //  `readId3v2Tag` and `readXingTag`. Each of these accepts a DataView-wrapped ArrayBuffer,\n    //  which should contain the actual mp3 data, and optionally an offset into the buffer.\n    //\n    // All methods return a description of the section read in the form of a hash containing\n    //  key-value pairs relevant to the section. For example the hash returned from\n    //  `readFrameHeader` always contains an `mpegAudioVersion` key of value \"MPEG Version 1\n    //  (ISO/IEC 11172-3)\" and a `layerDescription` key of value \"Layer III\". A description will\n    //  always have a `_section` hash with `type`, `byteLength` and `offset` keys:\n    //\n    //  * `type`: \"frame\", \"frameHeader\", \"Xing\" or \"ID3\"\n    //  * `byteLenfth`: Size of the section in bytes\n    //  * `offset`: Buffer offset at which this section resides\n\n    // ----\n\n    // ### Read a Frame Header\n    //\n    // Read and return description of header of frame located at `offset` of DataView `view`.\n    //  Returns `null` in the event that no frame header is found at `offset`\n    mp3Parser.readFrameHeader = function (view, offset) {\n        return lib.readFrameHeader(view, offset);\n    };\n\n    // ### Read a Frame\n    //\n    // Read and return description of frame located at `offset` of DataView `view`. Includes the\n    //  frame header description (see `readFrameHeader`) plus some basic information about the\n    //  frame - notably the frame's length in bytes. If `requireNextFrame` is set, the presence of\n    //  a _next_ valid frame will be required for _this_ frame to be regarded as valid. Returns\n    //  null in the event that no frame is found at `offset`\n    mp3Parser.readFrame = function (view, offset, requireNextFrame) {\n        return lib.readFrame(view, offset, requireNextFrame);\n    };\n\n    // ### Read the Last Frame\n    //\n    // Locate and return description of the very last valid frame in given DataView `view`. The\n    //  search is carried out in reverse, from given `offset` (or the very last octet if `offset`\n    //  is ommitted) to the first octet in the view. If `requireNextFrame` is set, the presence\n    //  of a next valid frame will be required for any found frame to be regarded as valid (causing\n    //  the method to essentially return the next-to-last frame on success). Returns `null` in the\n    //  event that no frame is found at `offset`\n    mp3Parser.readLastFrame = function (view, offset, requireNextFrame) {\n        offset || (offset = view.byteLength - 1);\n\n        var lastFrame = null;\n\n        for (; offset >= 0; --offset) {\n            if (view.getUint8(offset) === 255) {\n                // Located a candidate frame as 255 is a possible frame-sync byte\n                lastFrame = mp3Parser.readFrame(view, offset, requireNextFrame);\n                if (lastFrame) { return lastFrame; }\n            }\n        }\n\n        return null;\n    };\n\n    // ### Read the ID3v2 Tag\n    //\n    // Read and return description of [ID3v2 Tag](http://id3.org/id3v2.3.0) located at `offset` of\n    //  DataView `view`. (This will include any and all\n    //  [currently supported ID3v2 frames](https://github.com/biril/mp3-parser/wiki) located within\n    //  the tag). Returns `null` in the event that no tag is found at `offset`\n    mp3Parser.readId3v2Tag = function (view, offset) {\n        return id3v2Parser.readId3v2Tag(view, offset);\n    };\n\n    // ### Read the Xing Tag\n    //\n    // Read and return description of\n    //  [Xing / Lame Tag](http://gabriel.mp3-tech.org/mp3infotag.html) located at `offset` of\n    //  DataView `view`. Returns `null` in the event that no frame is found at `offset`\n    mp3Parser.readXingTag = function (view, offset) {\n        return xingParser.readXingTag(view, offset);\n    };\n\n    // ### Read all Tags up to First Frame\n    // Read and return descriptions of all tags found up to (and including) the very first frame.\n    //  Returns an array of sections which may include a description of a located ID3V2 tag, a\n    //  description of located Xing / Lame tag and a description of the a located first frame\n    //  ( See [this](http://www.rengels.de/computer/mp3tags.html) and\n    //  [this](http://stackoverflow.com/a/5013505) )\n    mp3Parser.readTags = function (view, offset) {\n        offset || (offset = 0);\n\n        var sections = [];\n        var section = null;\n        var isFirstFrameFound = false;\n        var bufferLength = view.byteLength;\n\n        var readers = [mp3Parser.readId3v2Tag, mp3Parser.readXingTag, mp3Parser.readFrame];\n        var numOfReaders = readers.length;\n\n        // While we haven't located the first frame, pick the next offset ..\n        for (; offset < bufferLength && !isFirstFrameFound; ++offset) {\n            // .. and try out each of the 'readers' on it\n            for (var i = 0; i < numOfReaders; ++i) {\n                section = readers[i](view, offset);\n\n                // If one of the readers successfully parses a section ..\n                if (section) {\n                    // .. store it ..\n                    sections.push(section);\n\n                    // .. and push the offset to the very end of end of that section. This way,\n                    //  we avoid iterating over offsets which definately aren't the begining of\n                    //  some section (they're part of the located section)\n                    offset += section._section.byteLength;\n\n                    // If the section we just parsed is a frame then we've actually located the\n                    //  first frame. Break out of the readers-loop making sure to set\n                    //  isFirstFrameFound (so that we also exit the outer loop)\n                    if (section._section.type === \"frame\") {\n                        isFirstFrameFound = true;\n                        break;\n                    }\n\n                    // The section is _not_ the first frame. So, having pushed the offset\n                    //  appropriately, retry all readers\n                    i = -1;\n                }\n            }\n        }\n\n        return sections;\n    };\n}));\n","import parser from 'mp3-parser';\n\nconst CHUNK_MAX_SIZE = 1000 * 1000;\nconst DEFAULT_CONCURRENCY = 4;\nconst CONCURRENCY =\n  ((typeof navigator !== 'undefined' && navigator.hardwareConcurrency) || 1) > 2\n    ? navigator.hardwareConcurrency\n    : DEFAULT_CONCURRENCY;\n\n/**\n * Creates a new ArrayBuffer out of two Uint8Arrays\n *\n * @private\n * @param   {Uint8Array}  baseUint8Array  first Uint8Array.\n * @param   {Uint8Array}  buffer          second Uint8Array.\n * @return  {ArrayBuffer}                  The new ArrayBuffer\n */\nfunction makeChunk(array1, array2) {\n  const tmp = new Uint8Array(array1.byteLength + array2.byteLength);\n  tmp.set(array1, 0);\n  tmp.set(array2, array1.byteLength);\n  return tmp.buffer;\n}\n\nfunction makeSaveChunk(chunkArrayBuffers, tagsUInt8Array, sourceUInt8Array) {\n  return function saveChunk(chunk) {\n    chunkArrayBuffers.push(\n      makeChunk(\n        tagsUInt8Array,\n        sourceUInt8Array.subarray(\n          chunk.frames[0]._section.offset,\n          chunk.frames[chunk.frames.length - 1]._section.offset +\n            chunk.frames[chunk.frames.length - 1]._section.byteLength\n        )\n      )\n    );\n  };\n}\n\nfunction emptyChunk(chunk) {\n  chunk.byteLength = 0;\n  chunk.frames.length = 0;\n}\n\nfunction addChunkFrame(chunk, frame) {\n  chunk.byteLength = chunk.byteLength + frame._section.byteLength;\n  chunk.frames.push(frame);\n}\n\nconst asyncWorker = (source, items, fn, output) => async () => {\n  let next;\n  while ((next = items.pop())) {\n    output[source.get(next)] = await fn(next);\n  }\n};\n\nfunction getArrayBuffer(file) {\n  return new Promise((resolve) => {\n    let fileReader = new FileReader();\n    fileReader.onloadend = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.readAsArrayBuffer(file);\n  });\n}\n\n// Use a promise wrapper on top of event based syntax\n// for browsers (Safari) which do not support promise-based syntax.\nfunction decodeArrayBuffer(audioCtx, arrayBuffer) {\n  return new Promise(audioCtx.decodeAudioData.bind(audioCtx, arrayBuffer));\n}\n\nasync function getFileAudioBuffer(file, audioCtx, options = {}) {\n  /* Copyright (c) 2019, Timothée 'Tim' Pillard, @ziir @tpillard - ISC */\n\n  const { concurrency = CONCURRENCY } = options;\n\n  const arrayBuffer = await getArrayBuffer(file);\n  const view = new DataView(arrayBuffer);\n\n  const tags = parser.readTags(view);\n  const firstFrame = tags.pop();\n  const uInt8Array = new Uint8Array(arrayBuffer);\n  const tagsUInt8Array = uInt8Array.subarray(0, firstFrame._section.offset);\n  const chunkArrayBuffers = [];\n  const saveChunk = makeSaveChunk(\n    chunkArrayBuffers,\n    tagsUInt8Array,\n    uInt8Array\n  );\n  let chunk = { byteLength: 0, frames: [] };\n  let next = firstFrame._section.offset + firstFrame._section.byteLength;\n  while (next) {\n    const frame = parser.readFrame(view, next);\n    next = frame && frame._section.nextFrameIndex;\n\n    if (frame) {\n      const chunkEnd =\n        chunk && chunk.byteLength + frame._section.byteLength >= CHUNK_MAX_SIZE;\n      if (chunkEnd) {\n        saveChunk(chunk);\n        emptyChunk(chunk);\n      }\n\n      addChunkFrame(chunk, frame);\n    }\n\n    if (chunk && (!frame || !next)) {\n      saveChunk(chunk);\n    }\n  }\n\n  const workers = [];\n  const source = new Map(chunkArrayBuffers.map((chunk, idx) => [chunk, idx]));\n  const audioBuffers = new Array(chunkArrayBuffers.length);\n  const decode = decodeArrayBuffer.bind(null, audioCtx);\n\n  for (let i = 0; i < Math.min(concurrency, source.size); i++) {\n    workers.push(\n      asyncWorker(source, chunkArrayBuffers, decode, audioBuffers)()\n    );\n  }\n  await Promise.all(workers);\n\n  const { numberOfChannels, sampleRate } = audioBuffers[0];\n  let length = audioBuffers.reduce((acc, current) => acc + current.length, 0);\n\n  const audioBuffer = audioCtx.createBuffer(\n    numberOfChannels,\n    length,\n    sampleRate\n  );\n\n  for (let j = 0; j < numberOfChannels; j++) {\n    let offset = 0;\n    for (let i = 0; i < audioBuffers.length; i++) {\n      audioBuffer.copyToChannel(audioBuffers[i].getChannelData(j), j, offset);\n      offset += audioBuffers[i].length;\n    }\n  }\n\n  return audioBuffer;\n}\n\nexport { getFileAudioBuffer };\n"],"names":["lib","b","octetToBinRep","octet","join","getFrameByteLength","kbitrate","samplingRate","padding","mpegVersion","layerVersion","sampleLength","sampleLengthMap","paddingSize","byteRate","Math","floor","getXingOffset","channelMode","mono","v1l1Bitrates","0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010","1011","1100","1101","1110","1111","v1l2Bitrates","v1l3Bitrates","v2l1Bitrates","v2l2Bitrates","v2l3Bitrates","v1SamplingRates","00","01","10","11","v2SamplingRates","v25SamplingRates","channelModes","mpegVersionDescription","layerDescription","bitrateMap","samplingRateMap","v1SampleLengths","v2SampleLengths","wordSeqFromStr","str","i","length","seq","charCodeAt","id3","xing","info","noOp","unsynchsafe","value","out","mask","isSeq","view","offset","getUint8","locateSeq","l","locateStrTrm","iso","ucs","trmOffset","readStr","String","fromCharCode","apply","Uint8Array","buffer","getUint16","slice","Uint16Array","readTrmStr","readFrameHeader","byteLength","b2","substr","header","_section","type","mpegAudioVersionBits","mpegAudioVersion","layerDescriptionBits","isProtected","protectionBit","b3","bitrateBits","bitrate","samplingRateBits","frameIsPaddedBit","frameIsPadded","framePadding","privateBit","b4","channelModeBits","readFrame","requireNextFrame","frame","head","nextFrameIndex","xingOffset","createModule","exports","mp3Id3v2Parser","id3v2TagFrameNames","AENC","APIC","CHAP","COMM","COMR","ENCR","EQUA","ETCO","GEOB","GRID","IPLS","LINK","MCDI","MLLT","OWNE","PRIV","PCNT","POPM","POSS","RBUF","RVAD","RVRB","SYLT","SYTC","TALB","TBPM","TCOM","TCON","TCOP","TDAT","TDLY","TENC","TEXT","TFLT","TIME","TIT1","TIT2","TIT3","TKEY","TLAN","TLEN","TMED","TOAL","TOFN","TOLY","TOPE","TORY","TOWN","TPE1","TPE2","TPE3","TPE4","TPOS","TPUB","TRCK","TRDA","TRSN","TRSO","TSIZ","TSRC","TSSE","TYER","TXXX","UFID","USER","USLT","WCOM","WCOP","WOAF","WOAR","WOAS","WORS","WPAY","WPUB","WXXX","readFrameContent","T","content","encoding","enc","offsetBeg","offsetTrm","description","W","language","text","ownerIdentifier","identifier","DataView","offsetNextStrTrm","values","push","privateData","counter","getUint32","email","rating","mimeType","pictureType","pictureData","id","startTime","endTime","startOffset","endOffset","offsetSubFrames","frames","subFrame","readId3v2TagFrame","size","flagsOctet1","flagsOctet2","read","readContent","charAt","name","readId3v2Tag","flagsOctet","tag","majorVersion","minorRevision","unsynchronisationFlag","extendedHeaderFlag","experimentalIndicatorFlag","tagEnd","require$$0","xingParser","readXingTag","mp3Parser","id3v2Parser","readLastFrame","lastFrame","readTags","sections","section","isFirstFrameFound","bufferLength","readers","numOfReaders","require$$1","require$$2","CONCURRENCY","navigator","hardwareConcurrency","makeSaveChunk","chunkArrayBuffers","tagsUInt8Array","sourceUInt8Array","chunk","array1","array2","tmp","set","makeChunk","subarray","emptyChunk","addChunkFrame","asyncWorker","source","items","fn","output","async","next","pop","get","decodeArrayBuffer","audioCtx","arrayBuffer","Promise","decodeAudioData","bind","getFileAudioBuffer","file","options","concurrency","resolve","fileReader","FileReader","onloadend","result","readAsArrayBuffer","getArrayBuffer","firstFrame","parser","uInt8Array","saveChunk","workers","Map","map","idx","audioBuffers","Array","decode","min","all","numberOfChannels","sampleRate","reduce","acc","current","audioBuffer","createBuffer","j","copyToChannel","getChannelData"],"mappings":"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"}